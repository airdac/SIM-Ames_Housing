boxTidwell(log(SalePrice)~LotFrontage, data = df_num2)
boxTidwell(log(SalePrice)~BedroomAbvGr, data = df_num2)
box.tidwell(log(SalePrice)~BedroomAbvGr, data=df_num2)
# Too large p-value
boxTidwell(log(SalePrice)~Fireplaces, data =df_num2)
# We apply log() to Fireplaces
boxTidwell(log(SalePrice)~WoodDeckSF, data = df_num2)
# We apply sqrt() to WoodDeckSF
boxTidwell(log(SalePrice)~OpenPorchSF, data = df_num2)
m4 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m4)
plot(m4)
AIC(m3, m4)
BIC(m3,m4)
AIC(m2, m3)
BIC(m2,m3)
# Chunk 1
# Load the data
if(!is.null(dev.list())) dev.off()
rm(list = ls())
train = read.csv("train.csv")
test = read.csv("test.csv")
# And the combination of both datasets is:
df = rbind(test, train[,-81])
# Chunk 2
# Import the necessary libraries and do a first EDA
library(car)
library(mice)
library(dplyr)
library(missMDA)
library(FactoMineR)
library(chemometrics)
library(DataExplorer)
library(corrplot)
library(DataExplorer)
# Create EDA report before any changes are made.
#create_report(train, output_format = "pdf_document", output_file = "train.pdf")
#create_report(test, output_format = "pdf_document", output_file = "test.pdf")
# Chunk 3
# With the summary, we can see that there are 80 variables in total.
summary(train)
# And the name of each feature are below.
str(train)
# Analyzing all features will be an exhausting work. So there should be some way to reduce the dimensions. According to the statement of the project, we should retain all numerical variables and 10 categorical variables.
# The categorical variable are below
Categorical_val = c("MSSubClass","MSZoning","Street","Alley","LotShape","LandContour","Utilities","LotConfig","LandSlope","Neighborhood","Condition1","Condition2","BldgType","HouseStyle","OverallQual","OverallCond","RoofStyle","RoofMatl","Exterior1st","Exterior2nd","MasVnrType","ExterQual","ExterCond","Foundation","BsmtQual","BsmtCond","BsmtExposure","BsmtFinType1","BsmtFinType2","Heating","HeatingQC","CentralAir","Electrical","KitchenQual","Functional","FireplaceQu","GarageType","GarageFinish","GarageQual","GarageCond","PavedDrive","PoolQC","Fence","MiscFeature","SaleType","SaleCondition", "MoSold")
# The numerical variables except the target are
Numerical_val = c("LotFrontage","LotArea","MasVnrArea","BsmtFinSF1","BsmtFinSF2","BsmtUnfSF","TotalBsmtSF","X1stFlrSF","X2ndFlrSF","GrLivArea","BsmtFullBath","BsmtHalfBath","FullBath","HalfBath","BedroomAbvGr","KitchenAbvGr","TotRmsAbvGrd","Fireplaces","GarageCars","GarageArea","WoodDeckSF","OpenPorchSF","EnclosedPorch","X3SsnPorch","ScreenPorch","MiscVal","YearBuilt","YearRemodAdd","GarageYrBlt","YrSold")
# And the date variables are
Date_val = c("YearBuilt","YearRemodAdd","GarageYrBlt","MoSold","YrSold")
# Some numerical variables just contain a few unique values, which means they can be converted to categorical. Below we can see which of them are.
sapply(select(train, Numerical_val), table)
m5 = lm(log(SalePrice) ~ LotFrontage+LotArea+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
# Chunk 1
# Clean workspace
if(!is.null(dev.list())) dev.off()
rm(list = ls())
# Chunk 2
# Load libraries
library(car)
library(mice)
library(dplyr)
library(missMDA)
library(FactoMineR)
library(chemometrics)
library(DataExplorer)
library(corrplot)
library(MASS)
library(effects)
# Chunk 3
# Load data
df = read.csv("train_impute.csv")
# Declare factors
df$OverallQual <- as.factor(df$OverallQual)
df$MSSubClass <- as.factor(df$MSSubClass)
char_var <- which(sapply(df, is.character))
df[,char_var] <- lapply(df[, char_var], as.factor)
# Chunk 4
df_num <- df[, which(sapply(df, is.numeric))]
m0 = lm(SalePrice ~ ., data=df_num)
summary(m0)
vif(m0)
# The X1stFlrSF, X2ndFlrSF, GrLivArea, has a vif correlation bigger than 10, indicating that we'll need to do some kind of transformation or simply remove it.
# Chunk 5
# Let's store the indices of the variables with at least one star in the lm and vif<5
id_num_star1 = c(1:5,15,17,21:23)
df_num1 <- df_num[, id_num_star1]
m1 = lm(SalePrice ~., data=df_num1)
summary(m1)
vif(m1)
corr_mat <- cor(df_num1)
corrplot(corr_mat)
cor.test(df_num1$YearBuilt, df_num1$YearRemodAdd)
corr_mat
# Chunk 6
id_num_star2 = c(1:3,5,15,17,21:23)
df_num2 <- df_num[, id_num_star2]
m2 = lm(SalePrice ~., data=df_num2)
summary(m2)
vif(m2)
corr_mat <- cor(df_num2)
corrplot(corr_mat)
corr_mat
# Chunk 7
Anova(m2)
# Chunk 8
plot(m2)
D_thresh <- 2/sqrt(dim(df_num2)[1]); D_thresh
# Chunk 10
step(m2)
# Chunk 11
#residualPlots(m2)
#avPlots(m2)
#crPlot(m2)
# Chunk 12
boxcox(m2)
# We should apply log(x) to SalePrice
m3 = lm(log(SalePrice)~., data=df_num2)
summary(m3)
# Chunk 13
par(mfrow=c(2,2))
plot(m3, id.n=5)
# Chunk 14
#boxTidwell(SalePrice ~ ., data=df_num2)   THIS GIVES ERROR because most variables have null values
# We'll assign 10^(-6) to all cells equal to 0 to be able to use boxTidwell without alterating too much the model
df_num2 = replace(df_num2, df_num2 == 0, 1e-6)
summary(df_num2)
# boxTidwell(log(SalePrice)~., data=df_num2) THIS GIVES ERROR AS WELL because the model has too many variables
boxTidwell(log(SalePrice) ~ LotArea+YearBuilt+MasVnrArea, data = df_num2)
# We should apply sqrt(LotArea). The lambda for YearBuilt is too large, so it would difficult to interpet the model using it. MasVnrArea has a too larger p-value, so we cannot reject the null hypothesis that lambda = 1.
boxTidwell(log(SalePrice)~LotFrontage, data = df_num2)
# Too small lambda
boxTidwell(log(SalePrice)~BedroomAbvGr, data = df_num2)
# Too large p-value
boxTidwell(log(SalePrice)~Fireplaces, data =df_num2)
# We apply log() to Fireplaces
boxTidwell(log(SalePrice)~WoodDeckSF, data = df_num2)
# We apply sqrt() to WoodDeckSF
boxTidwell(log(SalePrice)~OpenPorchSF, data = df_num2)
# Too small lambda
# Chunk 15
m4 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m4)
plot(m4)
# Chunk 16
AIC(m3, m4)
BIC(m3,m4)
m5 = lm(log(SalePrice) ~ LotFrontage+LotArea+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m5)
plot(m5)
AIC(m4,m5)
BIC(m4,m5)
m5 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+Fireplaces+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m5)
plot(m5)
AIC(m4,m5)
BIC(m4,m5)
m7 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num2)
summary(m7)
plot(m7)
AIC(m4,m7)
BIC(m4,m7)
m5 = lm(log(SalePrice) ~ LotFrontage+LotArea+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m5)
plot(m5)
AIC(m4,m5)
BIC(m4,m5)
summary(m4)
# Chunk 1
# Clean workspace
if(!is.null(dev.list())) dev.off()
rm(list = ls())
# Chunk 2
# Load libraries
library(car)
library(mice)
library(dplyr)
library(missMDA)
library(FactoMineR)
library(chemometrics)
library(DataExplorer)
library(corrplot)
library(MASS)
library(effects)
# Chunk 3
# Load data
df = read.csv("train_impute.csv")
# Declare factors
df$OverallQual <- as.factor(df$OverallQual)
df$MSSubClass <- as.factor(df$MSSubClass)
char_var <- which(sapply(df, is.character))
df[,char_var] <- lapply(df[, char_var], as.factor)
# Chunk 4
df_num <- df[, which(sapply(df, is.numeric))]
m0 = lm(SalePrice ~ ., data=df_num)
summary(m0)
vif(m0)
# The X1stFlrSF, X2ndFlrSF, GrLivArea, has a vif correlation bigger than 10, indicating that we'll need to do some kind of transformation or simply remove it.
# Chunk 5
# Let's store the indices of the variables with at least one star in the lm and vif<5
id_num_star1 = c(1:5,15,17,21:23)
df_num1 <- df_num[, id_num_star1]
m1 = lm(SalePrice ~., data=df_num1)
summary(m1)
vif(m1)
corr_mat <- cor(df_num1)
corrplot(corr_mat)
cor.test(df_num1$YearBuilt, df_num1$YearRemodAdd)
corr_mat
# Chunk 6
id_num_star2 = c(1:3,5,15,17,21:23)
df_num2 <- df_num[, id_num_star2]
m2 = lm(SalePrice ~., data=df_num2)
summary(m2)
vif(m2)
corr_mat <- cor(df_num2)
corrplot(corr_mat)
corr_mat
# Chunk 7
Anova(m2)
# Chunk 8
plot(m2)
D_thresh <- 2/sqrt(dim(df_num2)[1]); D_thresh
# Chunk 10
step(m2)
# Chunk 11
#residualPlots(m2)
#avPlots(m2)
#crPlot(m2)
# Chunk 12
boxcox(m2)
# We should apply log(x) to SalePrice
m3 = lm(log(SalePrice)~., data=df_num2)
summary(m3)
# Chunk 13
par(mfrow=c(2,2))
plot(m3, id.n=5)
# Chunk 14
#boxTidwell(SalePrice ~ ., data=df_num2)   THIS GIVES ERROR because most variables have null values
# We'll assign 10^(-6) to all cells equal to 0 to be able to use boxTidwell without alterating too much the model
df_num2 = replace(df_num2, df_num2 == 0, 1e-6)
summary(df_num2)
# boxTidwell(log(SalePrice)~., data=df_num2) THIS GIVES ERROR AS WELL because the model has too many variables
boxTidwell(log(SalePrice) ~ LotArea+YearBuilt+MasVnrArea, data = df_num2)
# We should apply sqrt(LotArea). The lambda for YearBuilt is too large, so it would difficult to interpet the model using it. MasVnrArea has a too large p-value, so we cannot reject the null hypothesis that lambda = 1.
boxTidwell(log(SalePrice)~LotFrontage, data = df_num2)
# Too small lambda
boxTidwell(log(SalePrice)~BedroomAbvGr, data = df_num2)
# Too large p-value
boxTidwell(log(SalePrice)~Fireplaces, data =df_num2)
# We apply log() to Fireplaces
boxTidwell(log(SalePrice)~WoodDeckSF, data = df_num2)
# We apply sqrt() to WoodDeckSF
boxTidwell(log(SalePrice)~OpenPorchSF, data = df_num2)
# Too small lambda
# Chunk 15
m4 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m4)
plot(m4)
# Chunk 16
AIC(m3, m4)
BIC(m3,m4)
# Chunk 17
m5 = lm(log(SalePrice) ~ LotFrontage+LotArea+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m5)
plot(m5)
AIC(m4,m5)
BIC(m4,m5)
# Chunk 18
m6 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+Fireplaces+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m6)
plot(m6)
AIC(m4,m6)
BIC(m4,m6)
m7 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num2)
summary(m7)
plot(m7)
AIC(m4,m7)
BIC(m4,m7)
m4 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num)
df_num3 <- df_num
df_num3$Fireplaces = df_num2
df_num3 <- df_num
df_num3$Fireplaces = df_num2
m9 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num2); summary(m9)
AIC(m4,m9)
plot(m9)
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
df_num3 <- df_num
df_num3$Fireplaces = df_num2
m9 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num3); summary(m9)
# Chunk 1
# Clean workspace
if(!is.null(dev.list())) dev.off()
rm(list = ls())
# Chunk 2
# Load libraries
library(car)
library(mice)
library(dplyr)
library(missMDA)
library(FactoMineR)
library(chemometrics)
library(DataExplorer)
library(corrplot)
library(MASS)
library(effects)
# Chunk 3
# Load data
df = read.csv("train_impute.csv")
# Declare factors
df$OverallQual <- as.factor(df$OverallQual)
df$MSSubClass <- as.factor(df$MSSubClass)
char_var <- which(sapply(df, is.character))
df[,char_var] <- lapply(df[, char_var], as.factor)
# Chunk 4
df_num <- df[, which(sapply(df, is.numeric))]
m0 = lm(SalePrice ~ ., data=df_num)
summary(m0)
vif(m0)
# The X1stFlrSF, X2ndFlrSF, GrLivArea, has a vif correlation bigger than 10, indicating that we'll need to do some kind of transformation or simply remove it.
# Chunk 5
# Let's store the indices of the variables with at least one star in the lm and vif<5
id_num_star1 = c(1:5,15,17,21:23)
df_num1 <- df_num[, id_num_star1]
m1 = lm(SalePrice ~., data=df_num1)
summary(m1)
vif(m1)
corr_mat <- cor(df_num1)
corrplot(corr_mat)
cor.test(df_num1$YearBuilt, df_num1$YearRemodAdd)
corr_mat
# Chunk 6
id_num_star2 = c(1:3,5,15,17,21:23)
df_num2 <- df_num[, id_num_star2]
m2 = lm(SalePrice ~., data=df_num2)
summary(m2)
vif(m2)
corr_mat <- cor(df_num2)
corrplot(corr_mat)
corr_mat
# Chunk 7
Anova(m2)
# Chunk 8
plot(m2)
D_thresh <- 2/sqrt(dim(df_num2)[1]); D_thresh
# Chunk 10
step(m2)
# Chunk 11
#residualPlots(m2)
#avPlots(m2)
#crPlot(m2)
# Chunk 12
boxcox(m2)
# We should apply log(x) to SalePrice
m3 = lm(log(SalePrice)~., data=df_num2)
summary(m3)
# Chunk 13
par(mfrow=c(2,2))
plot(m3, id.n=5)
# Chunk 14
#boxTidwell(SalePrice ~ ., data=df_num2)   THIS GIVES ERROR because most variables have null values
# We'll assign 10^(-6) to all cells equal to 0 to be able to use boxTidwell without alterating too much the model
df_num2 = replace(df_num2, df_num2 == 0, 1e-6)
summary(df_num2)
# boxTidwell(log(SalePrice)~., data=df_num2) THIS GIVES ERROR AS WELL because the model has too many variables
boxTidwell(log(SalePrice) ~ LotArea+YearBuilt+MasVnrArea, data = df_num2)
# We should apply sqrt(LotArea). The lambda for YearBuilt is too large, so it would difficult to interpet the model using it. MasVnrArea has a too large p-value, so we cannot reject the null hypothesis that lambda = 1.
boxTidwell(log(SalePrice)~LotFrontage, data = df_num2)
# Too small lambda
boxTidwell(log(SalePrice)~BedroomAbvGr, data = df_num2)
# Too large p-value
boxTidwell(log(SalePrice)~Fireplaces, data =df_num2)
# We apply log() to Fireplaces
boxTidwell(log(SalePrice)~WoodDeckSF, data = df_num2)
# We apply sqrt() to WoodDeckSF
boxTidwell(log(SalePrice)~OpenPorchSF, data = df_num2)
# Too small lambda
# Chunk 15
m4 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m4)
plot(m4)
# Chunk 16
AIC(m3, m4)
BIC(m3,m4)
# Chunk 17
m5 = lm(log(SalePrice) ~ LotFrontage+LotArea+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m5)
AIC(m4,m5)
BIC(m4,m5)
# Chunk 18
m6 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+Fireplaces+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2)
summary(m6)
AIC(m4,m6)
BIC(m4,m6)
# Chunk 19
m7 = lm(log(SalePrice) ~ LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea+
BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num2)
summary(m7)
AIC(m4,m7)
BIC(m4,m7)
# Chunk 20
m8 = lm(log(SalePrice)~LotFrontage+sqrt(LotArea)+YearBuilt+MasVnrArea
+BedroomAbvGr+Fireplaces+WoodDeckSF+OpenPorchSF,
data=df_num2); summary(m8)
m9 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num2); summary(m9)
m10 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+Fireplaces+sqrt(WoodDeckSF)+OpenPorchSF,
data=df_num2); summary(m10)
AIC(m4,m10)
AIC(m4,m10)
AIC(m4,m10)
df_num3 <- df_num
df_num3$Fireplaces = df_num2
m9 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num3); summary(m9)
df_num3 <- df_num
df_num3$Fireplaces = df_num2$Fireplaces
m9 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF,
data=df_num3); summary(m9)
AIC(m4,m9)
plot(m9)
df4 <- df_num
df4$Fireplaces = df_num2$Fireplaces
df4 <- df
df4$Fireplaces = df_num2$Fireplaces
df4 <- df
df4$Fireplaces = df_num2$Fireplaces
df4 <- df
df4$Fireplaces = df_num2$Fireplaces
m11 = lm(log(SalePrice)~LotFrontage+LotArea+YearBuilt+MasVnrArea
+BedroomAbvGr+log(Fireplaces)+WoodDeckSF+OpenPorchSF+
OverallQual,
data=df4); summary(m11)
AIC(m11)
# Chunk 1
# Load the data
if(!is.null(dev.list())) dev.off()
rm(list = ls())
train = read.csv("train.csv")
test = read.csv("test.csv")
# And the combination of both datasets is:
df = rbind(test, train[,-81])
# Chunk 2
# Import the necessary libraries and do a first EDA
library(car)
library(mice)
library(dplyr)
library(missMDA)
library(FactoMineR)
library(chemometrics)
library(DataExplorer)
library(corrplot)
library(DataExplorer)
library(MASS)
# Create EDA report before any changes are made.
#create_report(train, output_format = "pdf_document", output_file = "train.pdf")
#create_report(test, output_format = "pdf_document", output_file = "test.pdf")
# Chunk 3
# With the summary, we can see that there are 80 variables in total.
summary(train)
# And the name of each feature are below.
str(train)
# Analyzing all features will be an exhausting work. So there should be some way to reduce the dimensions. According to the statement of the project, we should retain all numerical variables and 10 categorical variables.
# The categorical variable are below
Categorical_val = c("MSSubClass","MSZoning","Street","Alley","LotShape","LandContour","Utilities","LotConfig","LandSlope","Neighborhood","Condition1","Condition2","BldgType","HouseStyle","OverallQual","OverallCond","RoofStyle","RoofMatl","Exterior1st","Exterior2nd","MasVnrType","ExterQual","ExterCond","Foundation","BsmtQual","BsmtCond","BsmtExposure","BsmtFinType1","BsmtFinType2","Heating","HeatingQC","CentralAir","Electrical","KitchenQual","Functional","FireplaceQu","GarageType","GarageFinish","GarageQual","GarageCond","PavedDrive","PoolQC","Fence","MiscFeature","SaleType","SaleCondition", "MoSold")
# The numerical variables except the target are
Numerical_val = c("LotFrontage","LotArea","MasVnrArea","BsmtFinSF1","BsmtFinSF2","BsmtUnfSF","TotalBsmtSF","X1stFlrSF","X2ndFlrSF","GrLivArea","BsmtFullBath","BsmtHalfBath","FullBath","HalfBath","BedroomAbvGr","KitchenAbvGr","TotRmsAbvGrd","Fireplaces","GarageCars","GarageArea","WoodDeckSF","OpenPorchSF","EnclosedPorch","X3SsnPorch","ScreenPorch","MiscVal","YearBuilt","YearRemodAdd","GarageYrBlt","YrSold")
# And the date variables are
Date_val = c("YearBuilt","YearRemodAdd","GarageYrBlt","MoSold","YrSold")
# Chunk 4
# Some numerical variables just contain a few unique values, which means they can be converted to categorical. Below we can see which of them are.
sapply(select(train, Numerical_val), table)
